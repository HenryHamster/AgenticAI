# Dungeons & Dialogue

> A turn-based, tile-centric economy simulator where LLM-powered agents explore, trade, and compete under the guidance of a Dungeon Master AI.

## Overview

Dungeons & Dialogue is an experimental game where autonomous AI agents navigate a shared world, make decisions, and compete for wealth. Each tile on the game board carries a natural-language description that evolves as players interact with it. A Dungeon Master AI orchestrates the world, adjudicates actions, and narrates outcomes, creating an emergent narrative driven entirely by language models.

### Key Features

- **LLM-Driven Gameplay**: Every decision, from player actions to world updates, is generated by large language models
- **Emergent Narratives**: Tile descriptions evolve based on player actions, creating a living history
- **Multi-Agent Competition**: Multiple AI agents compete simultaneously, each pursuing their own strategies
- **Modular Architecture**: Easily swap AI providers (OpenAI, Claude) or extend game mechanics
- **Full Persistence**: Complete game state can be saved and loaded via JSON serialization
- **Web Interface**: Real-time visualization of game state, player stats, and turn-by-turn playback

## Project Structure

```
AgenticAI/
├── backend/              # Python backend game engine
│   ├── src/
│   │   ├── app/         # Core game logic (Game, Player, DungeonMaster, Tile)
│   │   ├── services/    # AI integration and response parsing
│   │   ├── database/    # File-based persistence
│   │   └── core/        # Configuration and settings
│   ├── testing/         # Test scripts and utilities
│   ├── data/            # Game data and design documents
│   └── main.py          # Entry point
│
└── frontend/            # Next.js web interface
    ├── src/
    │   ├── app/         # Next.js pages (game list, game detail)
    │   ├── components/  # React components (board, timeline, stats)
    │   ├── services/    # API integration
    │   ├── types/       # TypeScript type definitions
    │   └── scripts/     # Mock data generation
    └── public/          # Static assets
```

## Quick Start

### Prerequisites

- **Backend**: Python 3.10+
- **Frontend**: Node.js 20+
- API keys for at least one LLM provider:
  - OpenAI API key (for GPT models)
  - Anthropic API key (for Claude models)

### Backend Setup

```bash
# Navigate to backend directory
cd backend

# Create virtual environment
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Set environment variables
export OPENAI_API_KEY="your_openai_key"
export CLAUDE_API_KEY="your_claude_key"

# Run tests
python testing/test_parser.py
python testing/test_openai_integration.py

# Run the game (experimental)
python main.py
```

### Frontend Setup

```bash
# Navigate to frontend directory
cd frontend

# Install dependencies
npm install

# Start development server
npm run dev
```

Open [http://localhost:3000](http://localhost:3000) to view the game interface.

## How It Works

### Gameplay Loop

1. **Player Actions**: Each AI agent observes tiles within its vision range and submits a single-sentence action intention
2. **DM Adjudication**: The Dungeon Master AI evaluates all player actions, considers the shared world state, and generates verdicts
3. **State Update**: Player stats (health, money) and tile descriptions are updated based on DM verdicts
4. **Broadcast**: Updated information is sent to all players for the next turn
5. **Repeat**: The loop continues until a win condition is met or the game ends

### Core Agents

#### Dungeon Master (Green Agent)
- Generates initial tile descriptions for the world map
- Adjudicates player actions against shared world state
- Updates tile descriptions based on events
- Narrates outcomes and maintains game balance

#### Players (White Agents)
- Autonomous LLM-powered agents with individual personalities
- Track stats: health, money, inventory, position
- Submit action intentions based on visible context
- Pursue wealth maximization (or custom objectives)

### AI Integration

The system supports multiple LLM providers through a unified `AIWrapper`:

- **OpenAI Service**: GPT-3.5, GPT-4, GPT-4o (via LangChain)
- **Claude Service**: Claude 3.x models (via LangChain)
- **Structured Output**: Pydantic-validated responses for reliable data extraction
- **Chat History**: Maintains conversation context for coherent multi-turn interactions

### Response Parsing

LLM responses are parsed using `DnDResponseParser`:
- Extracts JSON embedded in natural language text
- Validates character state (money, health, position, action)
- Validates world state (tile coordinates and descriptions)
- Falls back to defaults gracefully when parsing fails

### Persistence

All game state is serializable via the `Savable` interface:
- Game configuration and current turn
- All player states and histories
- Complete tile map with descriptions
- Dungeon Master state

Save/load operations use JSON format with comprehensive validation.

## Architecture Highlights

### Backend (Python)

**Core Application Layer** (`src/app/`)
- `Game.py`: Orchestrates turn-based loop, manages async player actions
- `Player.py`: AI agent wrapper with stats, position, and LLM integration
- `DungeonMaster.py`: World generation and action adjudication
- `Tile.py`: World grid locations with natural-language descriptions

**AI Service Layer** (`src/services/aiServices/`)
- `AIWrapper.py`: Multiplexes between AI providers, manages chat contexts
- `OpenAiService.py`: LangChain-based OpenAI integration
- `ClaudeService.py`: LangChain-based Anthropic integration
- `AiServicesBase.py`: Abstract interface for LLM services

**Response Parsing** (`src/services/responseParser/`)
- `parser.py`: Extracts structured data from LLM free-text
- `schema.py`: JSON schemas for character and world state
- `dataModels.py`: Pydantic models for validation

**Configuration** (`src/core/settings.py`)
- `GameConfig`: World size, vision radius, turn limits, wealth settings
- `AIConfig`: API keys, model selection, temperature, token limits

### Frontend (TypeScript/React)

**Pages** (`src/app/`)
- `page.tsx`: Game runs list with metadata cards
- `game/[id]/page.tsx`: Detailed game view with turn playback

**Components** (`src/components/`)
- `GameBoard.tsx`: 10x10 tile grid with terrain and player emojis
- `TurnTimeline.tsx`: Scrollable turn history with action details
- `PlayerStatsPanel.tsx`: Real-time player statistics
- `TileCell.tsx`: Individual tile rendering with hover tooltips

**Services** (`src/services/`)
- `api.ts`: API wrapper functions (currently using mock data)

## Current Status

### Completed
- Modular service-oriented architecture
- Multi-provider AI integration (OpenAI, Claude)
- Response parsing with schema validation
- Complete persistence system
- Async turn-based game loop
- Web frontend with turn-by-turn playback
- Mock data generation for testing

### In Progress
- Game verdict handling (`Game.handle_verdict`)
- Environment and session management
- Error handling and retry logic
- Comprehensive test coverage
- Backend API endpoints for frontend integration

### Roadmap
1. Complete DM verdict application to game state
2. Build REST API for frontend-backend communication
3. Add real-time WebSocket updates for live game viewing
4. Implement robust error handling and AI retry logic
5. Expand test coverage with mocked AI services
6. Add CLI interface for headless gameplay
7. Support custom player classes and victory conditions
8. Document sample scenarios and gameplay strategies

## Configuration

### Environment Variables

Create a `backend/.env` file with the following variables:

```bash
# AI Provider API Keys
OPENAI_API_KEY="your_openai_key"
CLAUDE_API_KEY="your_claude_key"

# Storage Configuration
STORAGE_TYPE="file"  # or "supabase"
FILE_DATA_DIR="./data"

# Supabase Configuration (if using Supabase storage)
SUPABASE_URL="your_supabase_url"
SUPABASE_KEY="your_supabase_key"
```

### Game Settings

Game configuration is managed through the API when creating games:

```python
# Example game configuration
{
    "world_size": 10,           # Grid size (10x10)
    "max_turns": 100,           # Maximum turns per game
    "currency_target": 1000,    # Victory condition
    "model_mode": "openai",      # AI provider
    "players": [
        {
            "name": "Player1",
            "starting_health": 100,
            "starting_currency": 100
        }
    ]
}
```

## Testing

### Docker-based Testing

```bash
# Run all tests
make test

# Run backend tests only
make test-backend

# Run frontend tests only
make test-frontend
```

### Manual Testing

```bash
# Backend tests
cd backend
python testing/main_test.py

# Frontend mock data generation
cd frontend
npx tsx src/scripts/generateAndSave.ts 5  # Generate 5 game runs
```

## API Reference

### Implemented Endpoints

```
GET  /api/v1/health                    # Health check
POST /api/v1/games/create              # Create new game
GET  /api/v1/games                     # List all games
GET  /api/v1/game/{game_id}            # Get game details
GET  /api/v1/game/eval/{game_id}       # Evaluate game responses
```

### API Documentation

Interactive API documentation is available at [http://localhost:8000/docs](http://localhost:8000/docs) when running the backend server.

## Development

### Docker Development Workflow

```bash
# Start development environment
make dev

# View logs
make logs

# Access container shells
make shell-backend
make shell-frontend

# Clean up resources
make clean
```

### Adding New Player Classes

1. Define class in `backend/src/app/Player.py`:
   ```python
   PLAYER_CLASSES = {
       "warrior": "A brave warrior focused on combat",
       "merchant": "A cunning trader maximizing profits"
   }
   ```

2. Players will use class descriptions in their decision-making context

### Adding Custom AI Providers

1. Extend `AiServicesBase` in `backend/src/services/aiServices/`
2. Implement required methods for AI communication
3. Register in `wrapper.py`

### Customizing Victory Conditions

Modify `backend/src/app/Game.py` to check custom win conditions during turn processing.

### Storage Backend Configuration

Switch between storage backends by setting `STORAGE_TYPE` in your `.env` file:
- `file`: JSON-based file storage (default)
- `supabase`: Cloud database storage

## Documentation

- **Backend Architecture**: See `backend/ReadMe.md`
- **Frontend Guide**: See `frontend/README.md`
- **Design Document**: See `backend/data/Agentic AI Master File.txt`
- **Supabase Setup**: See `SUPABASE_QUICKSTART.md`
- **Docker Development**: See `Makefile` for all available commands

## Contributing

Dungeons & Dialogue is under active development. Key areas for contribution:
- **AI Prompt Engineering**: Improve DM and player behaviors
- **Response Parsing**: Enhanced error recovery and validation
- **World Mechanics**: Additional terrain types and interactions
- **Performance**: Concurrent AI call optimization
- **Game Modes**: Alternative victory conditions and scenarios
- **Testing**: Comprehensive test coverage and mock services

## License

Part of the Dungeons & Dialogue project. Educational use encouraged.

## Acknowledgments

Built with:
- [LangChain](https://www.langchain.com/) for LLM orchestration
- [OpenAI API](https://openai.com/api/) for GPT models
- [Anthropic API](https://www.anthropic.com/) for Claude models
- [Next.js](https://nextjs.org/) for the web interface
- [Pydantic](https://pydantic-docs.helpmanual.io/) for data validation

---

**Status**: Active Development | **Last Updated**: December 2024
