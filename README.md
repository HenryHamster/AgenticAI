# AgenticAI: LLM-Powered Roguelike Economy Simulator

> A turn-based, tile-centric economy simulator where LLM-powered agents explore, trade, and compete under the guidance of a Dungeon Master AI.

## Overview

AgenticAI is an experimental game where autonomous AI agents navigate a shared world, make decisions, and compete for wealth. Each tile on the game board carries a natural-language description that evolves as players interact with it. A Dungeon Master AI orchestrates the world, adjudicates actions, and narrates outcomes, creating an emergent narrative driven entirely by language models.

### Key Features

- **LLM-Driven Gameplay**: Every decision, from player actions to world updates, is generated by large language models
- **Emergent Narratives**: Tile descriptions evolve based on player actions, creating a living history
- **Multi-Agent Competition**: Multiple AI agents compete simultaneously, each pursuing their own strategies
- **Modular Architecture**: Easily swap AI providers (OpenAI, Claude) or extend game mechanics
- **Full Persistence**: Complete game state can be saved and loaded via JSON serialization
- **Web Interface**: Real-time visualization of game state, player stats, and turn-by-turn playback

## Project Structure

```
AgenticAI/
├── backend/              # Python backend game engine
│   ├── src/
│   │   ├── app/         # Core game logic (Game, Player, DungeonMaster, Tile)
│   │   ├── services/    # AI integration and response parsing
│   │   ├── database/    # File-based persistence
│   │   └── core/        # Configuration and settings
│   ├── testing/         # Test scripts and utilities
│   ├── data/            # Game data and design documents
│   └── main.py          # Entry point
│
└── frontend/            # Next.js web interface
    ├── src/
    │   ├── app/         # Next.js pages (game list, game detail)
    │   ├── components/  # React components (board, timeline, stats)
    │   ├── services/    # API integration
    │   ├── types/       # TypeScript type definitions
    │   └── scripts/     # Mock data generation
    └── public/          # Static assets
```

## Quick Start

### Prerequisites

- **Backend**: Python 3.10+
- **Frontend**: Node.js 20+
- API keys for at least one LLM provider:
  - OpenAI API key (for GPT models)
  - Anthropic API key (for Claude models)

### Backend Setup

```bash
# Navigate to backend directory
cd backend

# Create virtual environment
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Set environment variables
export OPENAI_API_KEY="your_openai_key"
export CLAUDE_API_KEY="your_claude_key"

# Run tests
python testing/test_parser.py
python testing/test_openai_integration.py

# Run the game (experimental)
python main.py
```

### Frontend Setup

```bash
# Navigate to frontend directory
cd frontend

# Install dependencies
npm install

# Start development server
npm run dev
```

Open [http://localhost:3000](http://localhost:3000) to view the game interface.

## How It Works

### Gameplay Loop

1. **Player Actions**: Each AI agent observes tiles within its vision range and submits a single-sentence action intention
2. **DM Adjudication**: The Dungeon Master AI evaluates all player actions, considers the shared world state, and generates verdicts
3. **State Update**: Player stats (health, money) and tile descriptions are updated based on DM verdicts
4. **Broadcast**: Updated information is sent to all players for the next turn
5. **Repeat**: The loop continues until a win condition is met or the game ends

### Core Agents

#### Dungeon Master (Green Agent)
- Generates initial tile descriptions for the world map
- Adjudicates player actions against shared world state
- Updates tile descriptions based on events
- Narrates outcomes and maintains game balance

#### Players (White Agents)
- Autonomous LLM-powered agents with individual personalities
- Track stats: health, money, inventory, position
- Submit action intentions based on visible context
- Pursue wealth maximization (or custom objectives)

### AI Integration

The system supports multiple LLM providers through a unified `AIWrapper`:

- **OpenAI Service**: GPT-3.5, GPT-4, GPT-4o (via LangChain)
- **Claude Service**: Claude 3.x models (via LangChain)
- **Structured Output**: Pydantic-validated responses for reliable data extraction
- **Chat History**: Maintains conversation context for coherent multi-turn interactions

### Response Parsing

LLM responses are parsed using `DnDResponseParser`:
- Extracts JSON embedded in natural language text
- Validates character state (money, health, position, action)
- Validates world state (tile coordinates and descriptions)
- Falls back to defaults gracefully when parsing fails

### Persistence

All game state is serializable via the `Savable` interface:
- Game configuration and current turn
- All player states and histories
- Complete tile map with descriptions
- Dungeon Master state

Save/load operations use JSON format with comprehensive validation.

## Architecture Highlights

### Backend (Python)

**Core Application Layer** (`src/app/`)
- `Game.py`: Orchestrates turn-based loop, manages async player actions
- `Player.py`: AI agent wrapper with stats, position, and LLM integration
- `DungeonMaster.py`: World generation and action adjudication
- `Tile.py`: World grid locations with natural-language descriptions

**AI Service Layer** (`src/services/aiServices/`)
- `AIWrapper.py`: Multiplexes between AI providers, manages chat contexts
- `OpenAiService.py`: LangChain-based OpenAI integration
- `ClaudeService.py`: LangChain-based Anthropic integration
- `AiServicesBase.py`: Abstract interface for LLM services

**Response Parsing** (`src/services/responseParser/`)
- `parser.py`: Extracts structured data from LLM free-text
- `schema.py`: JSON schemas for character and world state
- `dataModels.py`: Pydantic models for validation

**Configuration** (`src/core/settings.py`)
- `GameConfig`: World size, vision radius, turn limits, wealth settings
- `AIConfig`: API keys, model selection, temperature, token limits

### Frontend (TypeScript/React)

**Pages** (`src/app/`)
- `page.tsx`: Game runs list with metadata cards
- `game/[id]/page.tsx`: Detailed game view with turn playback

**Components** (`src/components/`)
- `GameBoard.tsx`: 10x10 tile grid with terrain and player emojis
- `TurnTimeline.tsx`: Scrollable turn history with action details
- `PlayerStatsPanel.tsx`: Real-time player statistics
- `TileCell.tsx`: Individual tile rendering with hover tooltips

**Services** (`src/services/`)
- `api.ts`: API wrapper functions (currently using mock data)

## Current Status

### Completed
- Modular service-oriented architecture
- Multi-provider AI integration (OpenAI, Claude)
- Response parsing with schema validation
- Complete persistence system
- Async turn-based game loop
- Web frontend with turn-by-turn playback
- Mock data generation for testing

### In Progress
- Game verdict handling (`Game.handle_verdict`)
- Environment and session management
- Error handling and retry logic
- Comprehensive test coverage
- Backend API endpoints for frontend integration

### Roadmap
1. Complete DM verdict application to game state
2. Build REST API for frontend-backend communication
3. Add real-time WebSocket updates for live game viewing
4. Implement robust error handling and AI retry logic
5. Expand test coverage with mocked AI services
6. Add CLI interface for headless gameplay
7. Support custom player classes and victory conditions
8. Document sample scenarios and gameplay strategies

## Configuration

### Game Settings (`backend/src/core/settings.py`)

```python
class GameConfig:
    max_turns: int = 100              # Maximum turns per game
    world_size: int = 10              # Grid size (10x10 by default)
    starting_wealth: int = 100        # Initial player money
    starting_health: int = 100        # Initial player health
    player_vision: int = 2            # Visible tile radius (0 = current tile only)
    num_responses: int = 1            # DM verdicts per turn
```

### AI Settings (`backend/src/core/settings.py`)

```python
class AIConfig:
    openai_api_key: str               # From OPENAI_API_KEY env var
    claude_api_key: str               # From CLAUDE_API_KEY env var
    openai_model: str = "gpt-4o"      # Default OpenAI model
    claude_model: str = "claude-3-5-sonnet-20241022"
    openai_temperature: float = 0.7   # Response randomness
```

## Testing

### Backend Tests

```bash
# Test response parser (no API calls)
python testing/test_parser.py

# Test OpenAI integration (requires OPENAI_API_KEY)
python testing/test_openai_integration.py
```

### Frontend Mock Data

The frontend includes auto-generated mock data for testing:

```bash
# Generate custom mock data
cd frontend
npx tsx src/scripts/generateAndSave.ts 5  # Generate 5 game runs
```

## API Integration (Coming Soon)

### Expected Endpoints

```
GET  /api/game-runs          # List all game runs
GET  /api/game-runs/:id      # Get game run details
POST /api/game-runs          # Create new game
GET  /api/game-runs/:id/turn/:turnNumber  # Get specific turn state
```

## Development

### Adding New Player Classes

1. Define class in `backend/src/app/Player.py`:
   ```python
   PLAYER_CLASSES = {
       "warrior": "A brave warrior focused on combat",
       "merchant": "A cunning trader maximizing profits"
   }
   ```

2. Players will use class descriptions in their decision-making context

### Adding Custom AI Providers

1. Extend `AiServicesBase` in `backend/src/services/aiServices/`
2. Implement `ask_ai_response()`, `ask_ai_response_with_structured_output()`, `ask_isolated_ai_response()`
3. Register in `AIWrapper.py`

### Customizing Victory Conditions

Modify `backend/src/app/Game.py` to check custom win conditions during turn processing.

## Documentation

- **Backend Architecture**: See `backend/ReadMe.md`
- **Frontend Guide**: See `frontend/README_DUNGEON_MASTER.md`
- **Design Document**: See `backend/data/Agentic AI Master File.txt`

## Contributing

This project is under active development. Key areas for contribution:
- AI prompt engineering for better DM and player behaviors
- Enhanced response parsing and error recovery
- Additional terrain types and world mechanics
- Performance optimization for concurrent AI calls
- Alternative victory conditions and game modes

## License

Part of the AgenticAI Dungeon Master project. Educational use encouraged.

## Acknowledgments

Built with:
- [LangChain](https://www.langchain.com/) for LLM orchestration
- [OpenAI API](https://openai.com/api/) for GPT models
- [Anthropic API](https://www.anthropic.com/) for Claude models
- [Next.js](https://nextjs.org/) for the web interface
- [Pydantic](https://pydantic-docs.helpmanual.io/) for data validation

---

**Status**: Experimental | **Last Updated**: October 2024
